-- ServerStorage->FlimsyRod->script=CastScrpt
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- REFERENCES
local tool = script.Parent
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local FishDB = require(ReplicatedStorage:WaitForChild("FishDatabase"))
local CatchEvent = ReplicatedStorage:WaitForChild("CatchFish")

-- GUI REFERENCES
local playerGui = player:WaitForChild("PlayerGui")
local fishingGui = playerGui:WaitForChild("FishingGUI")
local chargeBg = fishingGui:WaitForChild("ChargeBackground")
local chargeBar = chargeBg:WaitForChild("Bar")
local rewardFrame = fishingGui:WaitForChild("RewardFrame")
local rewardLabel = rewardFrame:WaitForChild("FishNameLabel")

-- MINIGAME GUI
local catchFrame = fishingGui:WaitForChild("CatchFrame")
local catchTrack = catchFrame:WaitForChild("Track")
local catchZone = catchTrack:WaitForChild("CatchZone")
local fishIcon = catchTrack:WaitForChild("FishIcon")
local progressBar = catchFrame:WaitForChild("ProgressBackground"):WaitForChild("CurrentProgress")

-- DEFAULT SETTINGS (Overwritten by Fish Stats)
local DEFAULT_STATS = {
	FishSpeed = 0.02,
	BarSize = 0.3,
	PassiveDrain = 0.001,
	CatchGain = 0.003,
	-- Add these defaults so the script doesn't break on old fish
	ReelPower = 0.01,
	Gravity = 0.005
}

local currentStats = DEFAULT_STATS

-- VARIABLES
local bobber = nil
local isCharging = false
local currentPower = 0
local castConnection = nil
local minigameConnection = nil
local waitingForBite = false
local isFishing = false
local currentZone = "Any"
local isMouseDown = false
local bobberParams = nil

-- GAME VARIABLES
local barPos = 0
local fishPos = 0.5
local fishTarget = 0.5
local progress = 0.3
local REEL_POWER = 0.008 
local GRAVITY = 0.005

local handle = tool:WaitForChild("Handle")
local tipAttachment = handle:WaitForChild("TipAttachment")

-- NOTE: Old 'tool.Activated' code is REMOVED. 
-- We now use UserInputService at the bottom for Mobile/PC support.

-- 1. PHYSICS (Throwing)
function FireBobber(power)
	local tmpl = ReplicatedStorage:FindFirstChild("Bobber")
	if not tmpl then return end

	bobber = tmpl:Clone()
	bobber.Parent = workspace
	bobber.CFrame = tipAttachment.WorldCFrame

	local rope = Instance.new("RopeConstraint", bobber)
	rope.Attachment0 = tipAttachment
	local att1 = Instance.new("Attachment", bobber)
	rope.Attachment1 = att1
	rope.Visible = true
	rope.Thickness = 0.02
	rope.Length = (power * 2) + 5
	rope.Color = BrickColor.new("Institutional white")

	local vel = workspace.CurrentCamera.CFrame.LookVector * (power * 1.5) + Vector3.new(0, 15, 0)
	bobber.AssemblyLinearVelocity = vel

	castConnection = RunService.Heartbeat:Connect(CheckBobberCollision)
end

-- 2. COLLISION (Now uses Spatial Query to ignore Terrain issues)
function CheckBobberCollision()
	if not bobber then return end

	-- A. CHECK IF WE HIT WATER (Terrain OR Part)
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {bobber, player.Character}
	params.FilterType = Enum.RaycastFilterType.Exclude

	-- Check 5 studs down
	local res = workspace:Raycast(bobber.Position, Vector3.new(0, -5, 0), params)

	if res then
		local isWater = (res.Material == Enum.Material.Water) or (res.Instance.Name == "Water") or (res.Instance.Name == "WaterBlock")

		if isWater then
			-- B. ZONE DETECTION UPGRADE
			-- Instead of relying on the Raycast (which hits Terrain), we scan 
			-- a 5-stud radius around the bobber for ANY part with a "Zone" attribute.
			local nearbyParts = workspace:GetPartBoundsInRadius(bobber.Position, 5)
			local foundZone = "Any"

			for _, part in pairs(nearbyParts) do
				local attr = part:GetAttribute("Zone")
				if attr then
					foundZone = attr
					print("âœ… FOUND ZONE PART: " .. part.Name .. " | Zone: " .. foundZone)
					break -- We found a valid zone, stop looking
				end
			end

			currentZone = foundZone
			AnchorBobberInWater(res.Position.Y)
		else
			ResetFishing() -- Hit land
		end
	elseif bobber.Position.Y < -100 then
		ResetFishing() -- Void
	end
end

function AnchorBobberInWater(y)
	if castConnection then castConnection:Disconnect() end
	bobber.Anchored = true
	bobber.Position = Vector3.new(bobber.Position.X, y, bobber.Position.Z)

	local rope = bobber:FindFirstChild("RopeConstraint")
	if rope then rope.Length = (tipAttachment.WorldPosition - bobber.Position).Magnitude + 3 end

	waitingForBite = true
	print("Waiting for fish in Zone: " .. currentZone)

	-- REQUEST BITE FROM SERVER
	task.delay(math.random(2, 6), function()
		if waitingForBite and bobber then
			CatchEvent:FireServer("RequestBite", currentZone)
		end
	end)
end

-- 3. SERVER LISTENER
CatchEvent.OnClientEvent:Connect(function(action, data)
	if action == "Hooked" then
		StartMinigame(data)
	elseif action == "Reward" then
		if rewardLabel then rewardLabel.Text = "You caught a " .. data .. "!" end
		if rewardFrame then
			rewardFrame.Visible = true
			task.wait(3)
			rewardFrame.Visible = false
		end
	end
end)

-- 4. MINIGAME
function StartMinigame(fishName)
	if not waitingForBite then return end
	waitingForBite = false
	isFishing = true

	local fishData = FishDB.Fish[fishName]
	if fishData and fishData.Difficulty then
		currentStats = fishData.Difficulty
		print("Loaded difficulty for " .. fishName)
	else
		currentStats = DEFAULT_STATS
	end

	catchZone.Size = UDim2.new(currentStats.BarSize, 0, 1, 0)
	catchFrame.Visible = true

	barPos = 0.2
	fishPos = 0.5
	fishTarget = math.random()
	progress = 0.3
	isMouseDown = false

	minigameConnection = RunService.RenderStepped:Connect(UpdateMinigame)
end

function UpdateMinigame(dt)
		if isMouseDown then 
			barPos += currentStats.ReelPower 
		else 
			barPos -= currentStats.Gravity 
		end

		barPos = math.clamp(barPos, 0, 1 - currentStats.BarSize)

	-- AI
	fishPos = fishPos + (fishTarget - fishPos) * currentStats.FishSpeed
	if math.abs(fishPos - fishTarget) < 0.05 then fishTarget = math.random() * (1 - 0.1) end

	-- Collision
	local caught = (fishPos >= barPos) and (fishPos <= barPos + currentStats.BarSize)

	-- Progress
	if caught then
		progress += currentStats.CatchGain
		progressBar.BackgroundColor3 = Color3.fromRGB(85, 255, 127)
	else
		progress -= currentStats.PassiveDrain
		progressBar.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
	end
	progress = math.clamp(progress, 0, 1)

	-- UI
	catchZone.Position = UDim2.new(barPos, 0, 0, 0)
	fishIcon.Position = UDim2.new(fishPos, 0, 0.5, 0)
	progressBar.Size = UDim2.new(progress, 0, 1, 0)

	if progress >= 1 then WinGame() elseif progress <= 0 then LoseGame() end
end

function WinGame()
	print("CAUGHT IT!")
	CatchEvent:FireServer("ClaimCatch")
	ResetFishing()
end

function LoseGame()
	ResetFishing()
end

function ResetFishing()
	if castConnection then castConnection:Disconnect() end
	if minigameConnection then minigameConnection:Disconnect() end
	if bobber then bobber:Destroy() end
	bobber = nil
	isCharging = false
	waitingForBite = false
	isFishing = false
	isMouseDown = false
	if chargeBg then chargeBg.Visible = false end
	if catchFrame then catchFrame.Visible = false end
end

-- 5. UNIVERSAL INPUT (MOBILE & PC)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end 

	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then

		-- REELING (Minigame Active)
		if isFishing then
			isMouseDown = true
			return
		end

		-- CHARGING (Rod equipped, ready to cast)
		if tool.Parent == player.Character and not isFishing and not waitingForBite and not bobber then
			isCharging = true
			currentPower = 10
			chargeBg.Visible = true

			-- BOUNCING CHARGE LOGIC
			local chargeDirection = 1 -- 1 = Up, -1 = Down

			task.spawn(function()
				while isCharging do
					-- Move power based on direction
					currentPower = currentPower + (2 * chargeDirection)

					-- Bounce at Top (100)
					if currentPower >= 100 then
						currentPower = 100
						chargeDirection = -1 -- Start going down
					end

					-- Bounce at Bottom (10)
					if currentPower <= 10 then
						currentPower = 10
						chargeDirection = 1 -- Start going up
					end

					chargeBar.Size = UDim2.new(currentPower/100, 0, 1, 0)
					task.wait(0.01) -- Faster refresh for smoother bounce
				end
			end)
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		-- STOP REELING
		if isFishing then
			isMouseDown = false
		end

		-- FIRE CAST
		if isCharging then
			isCharging = false
			chargeBg.Visible = false
			FireBobber(currentPower)
		end
	end
end)

tool.Unequipped:Connect(ResetFishing)
